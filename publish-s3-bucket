#!/usr/bin/env bash
#
# Publish an S3 bucket containing the following from this repository:
#  - CloudFormation templates
#  - AMI assets.

set -o errexit
set -o nounset
set -o pipefail

show_help() {
    >&2 echo "Usage: publish-s3-bucket [-h]"
    >&2 echo ""
    >&2 echo "Publish an S3 bucket with the resources from this repository."
    >&2 echo "Must be run from the root of the xrd-eks repository."
}

LIST_LAMBDA_VERSIONS=0

# Parse the arguments
while [ $# -gt 0 ]; do
    case $1 in
        -h|--help )
            show_help
            exit 255
            ;;
        --list-lambda-versions )
            LIST_LAMBDA_VERSIONS=1
            shift
            ;;
        * )
            >&2 echo "Unknown option $1"
            show_help
            exit 1
            ;;
    esac
done

ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
BUCKET_NAME=${BUCKET_NAME:-"${ACCOUNT_ID}-xrd-quickstart"}
BUCKET_KEY_PREFIX=${BUCKET_KEY_PREFIX:-"xrd-eks/"}

AWS_REGION=${AWS_REGION:-$(aws configure get region)}

CF_DIR=cf-templates
AMI_ASSETS_DIR=ami_assets
SUBMODULES_DIR=submodules

# Lambdas in the upstream QuickStart bucket that the XRd stack depends on.
LAMBDAS=(
    "CleanupLambdas/lambda.zip"
    "CleanupLoadBalancers/lambda.zip"
    "CleanupSecurityGroupDependencies/lambda.zip"
    "DeleteBucketContents/lambda.zip"
    "EksClusterResource/awsqs-eks-cluster.zip"
    "FargateProfile/lambda.zip"
    "GetCallerArn/lambda.zip"
    "HelmReleaseResource/awsqs-kubernetes-helm.zip"
    "KubeGet/lambda.zip"
    "KubeManifest/lambda.zip"
    "ResourceReader/lambda.zip"
    "awscliLayer/lambda.zip"
    "boto3Layer/lambda.zip"
    "crhelperLayer/lambda.zip"
    "kubectlLayer/lambda.zip"
    "kubernetesResources/awsqs_kubernetes_apply.zip"
    "kubernetesResources/awsqs_kubernetes_apply_vpc.zip"
    "kubernetesResources/awsqs_kubernetes_get.zip"
    "kubernetesResources/awsqs_kubernetes_get_vpc.zip"
    "registerCustomResource/lambda.zip"
    "registerType/lambda.zip"
)

# Pinned versions of lambdas in the upstream QuickStart bucket.
get_lambda_version() {
    case $1 in
        "CleanupLambdas/lambda.zip")
            echo "xa.Oy15ZoH7.mIp_BuRwsL53sGNbT7WL"
            ;;
        "CleanupLoadBalancers/lambda.zip")
            echo "5CvkA46x0j2uGCcYVFeQwRhQlDnOonex"
            ;;
        "CleanupSecurityGroupDependencies/lambda.zip")
            echo "gBBk2SBA0PMtXpLCX3NfVcyx4iLYQffa"
            ;;
        "DeleteBucketContents/lambda.zip")
            echo "TXgf9J8CzPlR9pIq2q8PAGichTjSVVQs"
            ;;
        "EksClusterResource/awsqs-eks-cluster.zip")
            echo "8nSWtXCsy9RKhTj80Fqxxy8BqPfdTVkl"
            ;;
        "FargateProfile/lambda.zip")
            echo "6TSPoPHqDS5RBuhHXK7c5nY1cWSQQWAN"
            ;;
        "GetCallerArn/lambda.zip")
            echo "aHK8rwSAtRi_VvXb93WSZeAPfkJRP1i1"
            ;;
        "HelmReleaseResource/awsqs-kubernetes-helm.zip")
            echo "xNMvfhXEo5m.QiVi42r2VGEduQfitDe9"
            ;;
        "KubeGet/lambda.zip")
            echo "D4Ie05qzJFw9phLxGl0c4jokEDe_3vOr"
            ;;
        "KubeManifest/lambda.zip")
            echo "eJ31WdSxuVyMjS1nBuHTVFUl.C9RvMiN"
            ;;
        "ResourceReader/lambda.zip")
            echo "M5QA7S.xPYbQ.Iu0hMaZoR49Mi3YpuSn"
            ;;
        "awscliLayer/lambda.zip")
            echo "yE8GC35WKjLIkee5PL.Y7eCFwnlcREfW"
            ;;
        "boto3Layer/lambda.zip")
            echo "MS7X8oS8XwglcBtvEO.H7wJkE9TldXaK"
            ;;
        "crhelperLayer/lambda.zip")
            echo "JiHzMw61.BY6cixU9XKvkYdjpf2Pw2o5"
            ;;
        "kubectlLayer/lambda.zip")
            echo "6vP5cViYr5Rgq5UjvLPQAT4Rk.ZHm.FC"
            ;;
        "kubernetesResources/awsqs_kubernetes_apply.zip")
            echo "KSvh_7_YqcOZbD4MiSvQaKZZbnsWne0o"
            ;;
        "kubernetesResources/awsqs_kubernetes_apply_vpc.zip")
            echo "4N_f.OTK6buavdceOsH.RUy3Qyxes643"
            ;;
        "kubernetesResources/awsqs_kubernetes_get.zip")
            echo "VqcyMGXFBp5N0R9YFz5RZ9vhdezagn6p"
            ;;
        "kubernetesResources/awsqs_kubernetes_get_vpc.zip")
            echo "Tp.TsI47FW_hGmRte1Kna5ujiZ.m5aAq"
            ;;
        "registerCustomResource/lambda.zip")
            echo "VYQpmfwS.PKRdHIAXTtWe_.K1dBuc3XX"
            ;;
        "registerType/lambda.zip")
            echo "s3kDkK67t2.qn1caBkqBLlHL2Bblf.b9"
            ;;
        *)
            2>&1 "Unrecognized lambda: $1"
            exit 2
    esac
}
    
create_bucket() {
    if [ "${AWS_REGION}" != "us-east-1" ]; then
        aws s3api head-bucket --bucket "${BUCKET_NAME}" >/dev/null 2>&1 || {
            aws s3api create-bucket \
                --bucket "${BUCKET_NAME}" \
                --create-bucket-configuration "{ \"LocationConstraint\": \"${AWS_REGION}\" }"
        }
    else
        aws s3api head-bucket --bucket "${BUCKET_NAME}" >/dev/null 2>&1 || {
            aws s3api create-bucket --bucket "${BUCKET_NAME}"
        }
    fi

    POLICY='{
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::'"${BUCKET_NAME}"'/'"${BUCKET_KEY_PREFIX}"''"${CF_DIR}"'/*"
            },
            {
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::'"${BUCKET_NAME}"'/'"${BUCKET_KEY_PREFIX}"''"${AMI_ASSETS_DIR}"'/*"
            }
        ]
    }'

    aws s3api put-public-access-block --bucket "${BUCKET_NAME}" --public-access-block-configuration "BlockPublicPolicy=false"
    aws s3api put-bucket-policy --bucket "${BUCKET_NAME}" --policy "${POLICY}"
}

sync_dir() {
    local DIR=$1
    aws s3 sync --delete "./${DIR}/" "s3://${BUCKET_NAME}/${BUCKET_KEY_PREFIX}${DIR}/"
}

copy_lambda() {
    local KEY=$1
    local VERSION=$2
    echo -n "Copying $KEY, version $VERSION..."
    >/dev/null aws s3api copy-object \
        --bucket "${BUCKET_NAME}" \
        --key "${BUCKET_KEY_PREFIX}submodules/${KEY}" \
        --copy-source "aws-quickstart-${AWS_REGION}/${KEY}?versionId=${VERSION}" \
        --metadata-directive REPLACE
    echo " done"
}

list_lambda_versions() {
    local LAMBDA=$1
    aws s3api list-object-versions \
        --bucket "aws-quickstart-${AWS_REGION}" \
        --prefix "quickstart-amazon-eks/functions/packages/${LAMBDA}" \
        --query 'Versions[].[Key,LastModified,VersionId]' \
        --no-cli-pager
}

if [ ${LIST_LAMBDA_VERSIONS} -eq 1 ]; then
    echo "Listing upstream QuickStart lambda versions..."
    for LAMBDA in "${LAMBDAS[@]}"; do
        get_latest_version "${LAMBDA}"
    done
    exit 0
fi

echo "Checking git submodules are recursively checked out..."
git submodule status --recursive 2>/dev/null | while IFS= read -r LINE; do
    if [ "${LINE:0:1}" = "-" ]; then
        2>&1 echo "Submodules are not recursively checked out."
        2>&1 echo "Run 'git submodule update --init --recursive' and try again."
        exit 2
    fi
done

echo "Creating bucket ${BUCKET_NAME}..."
create_bucket

echo "Syncing CF templates to bucket..."
sync_dir ${CF_DIR}

echo "Syncing AMI assets to bucket..."
sync_dir ${AMI_ASSETS_DIR}

echo "Syncing submodules to bucket..."
sync_dir ${SUBMODULES_DIR}

echo "Syncing QuickStart packages to bucket, this may take a minute..."
for LAMBDA in "${LAMBDAS[@]}"; do
    VERSION=$(get_lambda_version "${LAMBDA}")
    copy_lambda "quickstart-amazon-eks/functions/packages/${LAMBDA}" "${VERSION}"
done

# Output the details to be used in the CF stacks.
echo ""
echo "Successfully populated S3 bucket"
echo "Use the following values in your XRd CloudFormation stack:"
echo "  XRd resource S3 bucket name: ${BUCKET_NAME}"
echo "  XRd resource S3 bucket region: ${AWS_REGION}"
echo "  XRd resource S3 bucket key prefix: ${BUCKET_KEY_PREFIX}"
